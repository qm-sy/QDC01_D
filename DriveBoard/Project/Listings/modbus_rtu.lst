C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/18/2025 12:14:17 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS_RTU
OBJECT MODULE PLACED IN ..\Output\modbus_rtu.obj
COMPILER INVOKED BY: D:\APP\Keil_v5\C51\BIN\C51.EXE ..\Emembed\Src\modbus_rtu.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..
                    -\BSP\Inc;..\Core\Inc;..\Driver;..\Emembed\Inc;..\SYSTEM\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus_rtu.lst) OBJECT(
                    -..\Output\modbus_rtu.obj)

line level    source

   1          #include "modbus_rtu.h"
   2          
   3          MODBIS_INFO modbus;
   4          
   5          /**
   6           * @brief       modbus_rtu  无奇偶校验
   7           *
   8           * @param   void
   9           *
  10           * @return  void 
  11          **/
  12          void Modbus_Event_485( void )
  13          {
  14   1          uint16_t crc,rccrc;
  15   1          
  16   1          /*1.接收完毕                                           */
  17   1          if( rs485.RX4_rev_end_Flag == 1 )
  18   1          {
  19   2              /*2.清空接收完毕标志位                              */    
  20   2              rs485.RX4_rev_end_Flag = 0;
  21   2      
  22   2              /*3.CRC校验                                         */
  23   2              crc = MODBUS_CRC16(rs485.RX4_buf, rs485.RX4_rev_cnt-2);
  24   2              rccrc = (rs485.RX4_buf[rs485.RX4_rev_cnt-1]) | (rs485.RX4_buf[rs485.RX4_rev_cnt-2]<<8);
  25   2      
  26   2              /*4.清空接收计数                                    */
  27   2              rs485.RX4_rev_cnt = 0; 
  28   2      
  29   2              /*5.CRC校验通过，进行地址域校验                      */
  30   2              if( crc == rccrc )
  31   2              {
  32   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  33   3                  if( rs485.RX4_buf[0] == ADDR_485 )
  34   3                  {
  35   4                      switch ( rs485.RX4_buf[1] )
  36   4                      {
  37   5                          case 0x03:
  38   5                              Modbus_Fun3_485();
  39   5                              break;
  40   5      
  41   5                          case 0x04:
  42   5                              Modbus_Fun4_485();
  43   5                              break;
  44   5      
  45   5                          case 0x06:
  46   5                              Modbus_Fun6_485();
  47   5                              break;  
  48   5      
  49   5                          case 0x10:  
  50   5                              Modbus_Fun16_485();
  51   5      
  52   5                          default:
  53   5                              break;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/18/2025 12:14:17 PAGE 2   

  54   5                      }
  55   4                  }
  56   3              }
  57   2          }
  58   1      }
  59          
  60          
  61          /**
  62           * @brief       modbus_rtu  无奇偶校验
  63           *
  64           * @param   void
  65           *
  66           * @return  void 
  67          **/
  68          void Modbus_Event_Sata( void )
  69          {
  70   1          uint16_t crc,rccrc;
  71   1          
  72   1          /*1.接收完毕                                           */
  73   1          if( sata.RX1_rev_end_Flag == 1 )
  74   1          {
  75   2              /*2.清空接收完毕标志位                              */    
  76   2              sata.RX1_rev_end_Flag = 0;
  77   2      
  78   2              /*3.CRC校验                                         */
  79   2              crc = MODBUS_CRC16(sata.RX1_buf, sata.RX1_rev_cnt-2);
  80   2              rccrc = (sata.RX1_buf[sata.RX1_rev_cnt-2]) | (sata.RX1_buf[sata.RX1_rev_cnt-1]<<8);
  81   2      
  82   2              /*4.清空接收计数                                    */
  83   2              sata.RX1_rev_cnt = 0; 
  84   2      
  85   2              /*5.CRC校验通过，进行地址域校验                      */
  86   2              if( crc == rccrc )
  87   2              {
  88   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  89   3                  if( sata.RX1_buf[0] == ADDR_SATA )
  90   3                  {
  91   4                      switch ( sata.RX1_buf[1] )
  92   4                      {
  93   5                          case 0x03:
  94   5                              Modbus_Fun3_Sata();
  95   5      
  96   5                              break;
  97   5      
  98   5                          case 0x04:
  99   5                              Modbus_Fun4_Sata();
 100   5                              
 101   5                              break;
 102   5      
 103   5                          case 0x06:
 104   5                              Modbus_Fun6_Sata();
 105   5      
 106   5                              break;  
 107   5      
 108   5                          case 0x10:  
 109   5                              Modbus_Fun16_Sata();
 110   5      
 111   5                          default:
 112   5                              break;
 113   5                      }
 114   4                  }
 115   3              }
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/18/2025 12:14:17 PAGE 3   

 116   2          }
 117   1      }
 118          
 119          /**
 120           * @brief       读输入寄存器  03
 121           *
 122           * @param   void
 123           *
 124           * @return  void 
 125          **/
 126          void Modbus_Fun3_485( void )
 127          {
 128   1          uint16_t i;
 129   1      
 130   1          modbus.send_value_addr  = 3;                //DATA1 H 位置
 131   1          modbus.byte_cnt   = (rs485.RX4_buf[4]<<8 | rs485.RX4_buf[5]) *2;
 132   1          modbus.start_addr = rs485.RX4_buf[2]<<8 | rs485.RX4_buf[3];
 133   1      
 134   1          rs485.TX4_buf[0]  = ADDR_485;                //Addr
 135   1          rs485.TX4_buf[1]  = 0x03;                   //Fun
 136   1          rs485.TX4_buf[2]  = modbus.byte_cnt;        //Byte Count
 137   1      
 138   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
 139   1          {
 140   2              /*    每次循环前初始化byte_info                       */
 141   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
 142   2              switch (i)
 143   2              {   
 144   3                  /*  40001 风速查询                     */
 145   3                  case 0x00:
 146   3      
 147   3      
 148   3                      break;
 149   3      
 150   3                  /*  40002 LED开关状态查询                     */    
 151   3                  case 0x01:
 152   3      
 153   3                      break;
 154   3      
 155   3                  /*  40003 3路220V开关使能查询                         */
 156   3                  case 0x02:    
 157   3      
 158   3                      break;
 159   3      
 160   3                  /*  40004 同步状态查询              */
 161   3                  case 0x03:    
 162   3      
 163   3      
 164   3                      break;
 165   3      
 166   3                  /*  40005 工作模式查询                     */
 167   3                  case 0x04:   
 168   3      
 169   3                      break;
 170   3      
 171   3                  /*  40006 报警温度查询                     */
 172   3                  case 5:   
 173   3              
 174   3      
 175   3                      break;
 176   3                  default:
 177   3                      break;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/18/2025 12:14:17 PAGE 4   

 178   3              }
 179   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 180   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 181   2          }
 182   1          slave_to_master_485(0x03,3 + modbus.byte_cnt);
 183   1      }
 184          
 185          
 186          /**
 187           * @brief       读输入寄存器  03
 188           *
 189           * @param   void
 190           *
 191           * @return  void 
 192          **/
 193          void Modbus_Fun3_Sata( void )
 194          {
 195   1          uint16_t i;
 196   1      
 197   1          modbus.send_value_addr  = 3;                //DATA1 H 位置
 198   1          modbus.byte_cnt   = (sata.RX1_buf[4]<<8 | sata.RX1_buf[5]) *2;
 199   1          modbus.start_addr = sata.RX1_buf[2]<<8 | sata.RX1_buf[3];
 200   1      
 201   1          sata.TX1_buf[0]  = ADDR_SATA;                //Addr
 202   1          sata.TX1_buf[1]  = 0x03;                   //Fun
 203   1          sata.TX1_buf[2]  = modbus.byte_cnt;        //Byte Count
 204   1      
 205   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
 206   1          {
 207   2              /*    每次循环前初始化byte_info                       */
 208   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
 209   2              switch (i)
 210   2              {   
 211   3                  /*  40001 胶辊加热                     */
 212   3                  case 0x00:
 213   3                      modbus.byte_info_H = qdc_info.roller_temp;
 214   3                      modbus.byte_info_L = qdc_info.roller_switch;
 215   3      
 216   3                      break;
 217   3      
 218   3                  /*  40002 LED开关状态查询                     */    
 219   3                  case 0x01:
 220   3                      modbus.byte_info_H = 0x00;
 221   3                      modbus.byte_info_L = qdc_info.led_switch;
 222   3      
 223   3                      break;
 224   3      
 225   3                  /*  40003 风扇                         */
 226   3                  case 0x02:    
 227   3                      modbus.byte_info_H = 0x00;
 228   3                      modbus.byte_info_L = qdc_info.fan_level;
 229   3      
 230   3                      break;
 231   3      
 232   3                  /*  40004 底板加热              */
 233   3                  case 0x03:    
 234   3                      modbus.byte_info_H = qdc_info.board_temp;
 235   3                      modbus.byte_info_L = qdc_info.board_switch;
 236   3      
 237   3                      break;
 238   3      
 239   3                  /*  40005 墨囊加热                     */
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/18/2025 12:14:17 PAGE 5   

 240   3                  case 0x04:   
 241   3                      modbus.byte_info_H = 0x00;
 242   3                      modbus.byte_info_L = qdc_info.inksac_switch;
 243   3      
 244   3                      break;
 245   3      
 246   3                  /*  40006 循环控制                     */
 247   3                  case 0x05:   
 248   3                      modbus.byte_info_H = (qdc_info.cir_stop_time << 1) | (qdc_info.cir_start_time >> 5);
 249   3                      modbus.byte_info_L = qdc_info.cir_switch | (qdc_info.cir_start_time << 3);
 250   3                      
 251   3                      break;
 252   3                  /*  40007 搅拌控制                     */
 253   3                  case 0x06:   
 254   3                      modbus.byte_info_H = (qdc_info.stir_stop_time << 1) | (qdc_info.stir_start_time >> 5);
 255   3                      modbus.byte_info_L = qdc_info.stir_switch | (qdc_info.stir_start_time << 3);
 256   3      
 257   3                      break;
 258   3      
 259   3                  /*  40008  缺墨延时时间                      */
 260   3                  case 0x07:   
 261   3                      modbus.byte_info_H = 0x00;
 262   3                      modbus.byte_info_L = qdc_info.ink_out_time;
 263   3                      
 264   3                      break;
 265   3      
 266   3                  default:
 267   3                      break;
 268   3              }
 269   2              sata.TX1_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 270   2              sata.TX1_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 271   2          }
 272   1          slave_to_master_Sata(0x03,3 + modbus.byte_cnt);
 273   1      }
 274          
 275          /**
 276           * @brief       读输出寄存器  04
 277           *
 278           * @param   void
 279           *
 280           * @return  void 
 281          **/
 282          void Modbus_Fun4_485( void )
 283          {
 284   1          uint16_t i;
 285   1      
 286   1          modbus.send_value_addr  = 3;                 //DATA1 H 位置
 287   1          modbus.byte_cnt   = (rs485.RX4_buf[4]<<8 | rs485.RX4_buf[5]) *2;
 288   1          modbus.start_addr = rs485.RX4_buf[2]<<8 | rs485.RX4_buf[3];
 289   1      
 290   1          rs485.TX4_buf[0]  = ADDR_485;                //Addr
 291   1          rs485.TX4_buf[1]  = 0x04;                   //Fun
 292   1          rs485.TX4_buf[2]  = modbus.byte_cnt;        //Byte Count
 293   1      
 294   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
 295   1          {
 296   2              /*    每次循环前初始化byte_info                       */
 297   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
 298   2              switch (i)
 299   2              {
 300   3                  /*  30001  NTC1、NTC2温度查询                           */
 301   3                  case 0x00:
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/18/2025 12:14:17 PAGE 6   

 302   3      
 303   3      
 304   3                      break;
 305   3      
 306   3                  /*  30002  NTC3、NTC4温度查询                */
 307   3                  case 0x01:
 308   3      
 309   3      
 310   3                      break;
 311   3      
 312   3                  /*  30003 环境温湿度查询                   */
 313   3                  case 0x02:
 314   3      
 315   3                      break;
 316   3      
 317   3                  /*  30004 Signal_IN状态查询                   */
 318   3                  case 0x03:
 319   3       
 320   3      
 321   3                      break;
 322   3                      
 323   3                  /*  30005 运行时间（min）                   */
 324   3                  case 0x04:
 325   3      
 326   3                      break;
 327   3      
 328   3                  /*  30006 运行时间（h）                   */
 329   3                  case 0x05:
 330   3          
 331   3      
 332   3                      break;
 333   3      
 334   3                  default:
 335   3                      break;
 336   3              }
 337   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 338   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 339   2          }
 340   1          slave_to_master_485(0x04,3 + modbus.byte_cnt);
 341   1      }
 342          
 343          
 344          /**
 345           * @brief       读输出寄存器  04
 346           *
 347           * @param   void
 348           *
 349           * @return  void 
 350          **/
 351          void Modbus_Fun4_Sata( void )
 352          {
 353   1          uint16_t i;
 354   1      
 355   1          modbus.send_value_addr  = 3;                 //DATA1 H 位置
 356   1          modbus.byte_cnt   = (sata.RX1_buf[4]<<8 | sata.RX1_buf[5]) *2;
 357   1          modbus.start_addr = sata.RX1_buf[2]<<8 | sata.RX1_buf[3];
 358   1      
 359   1          sata.TX1_buf[0]  = ADDR_SATA;                //Addr
 360   1          sata.TX1_buf[1]  = 0x04;                   //Fun
 361   1          sata.TX1_buf[2]  = modbus.byte_cnt;        //Byte Count
 362   1      
 363   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/18/2025 12:14:17 PAGE 7   

 364   1          {
 365   2              /*    每次循环前初始化byte_info                       */
 366   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
 367   2              switch (i)
 368   2              {
 369   3                  /*  30001  1~7通道液位信息                           */
 370   3                  case 0x00:
 371   3                      modbus.byte_info_H = qdc_info.level_info2;
 372   3                      modbus.byte_info_L = qdc_info.level_info1;
 373   3      
 374   3                      break;
 375   3      
 376   3                  /*  30002 废墨液位信息                 */
 377   3                  case 0x01:
 378   3                      waste_ink_scan();
 379   3                      modbus.byte_info_H = 0x00;
 380   3                      modbus.byte_info_L = qdc_info.waste_ink;
 381   3      
 382   3                      break;
 383   3      
 384   3                  /*  30003 环境温湿度查询                   */
 385   3                  case 0x02:
 386   3                      modbus.byte_info_H = temp.dht11_humidity;
 387   3                      modbus.byte_info_L = temp.dht11_temp;
 388   3      
 389   3                      break;
 390   3      
 391   3                  /*  30004 NTC温度                  */
 392   3                  case 0x03:
 393   3                      modbus.byte_info_H = 0x00;
 394   3                      modbus.byte_info_L = temp.temp_value1;
 395   3      
 396   3                      break;
 397   3                      
 398   3                  /*  30005 热电堆温度                   */
 399   3                  case 0x04:
 400   3                      modbus.byte_info_H = 0x00;
 401   3                      modbus.byte_info_L = 25;
 402   3                      
 403   3                      break;
 404   3      
 405   3                  default:
 406   3                      break;
 407   3              }
 408   2              sata.TX1_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 409   2              sata.TX1_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 410   2          }
 411   1          slave_to_master_Sata(0x04,3 + modbus.byte_cnt);
 412   1      }
 413          
 414          /**
 415           * @brief       写单个输出寄存器  06
 416           *
 417           * @param   void
 418           *
 419           * @return  void 
 420          **/
 421          void Modbus_Fun6_485( void )
 422          {
 423   1          switch (rs485.RX4_buf[3])
 424   1          {
 425   2              /*  40001  风速设置                 */
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/18/2025 12:14:17 PAGE 8   

 426   2              case 0x00:                  
 427   2      
 428   2                  break;
 429   2      
 430   2              /*  40002  LED 开关状态设置                          */
 431   2              case 0x01:                                         
 432   2      
 433   2      
 434   2                  break;
 435   2      
 436   2              /*  40003 三路220V输出使能设置                          */
 437   2              case 0x02:                                         
 438   2      
 439   2                  break;  
 440   2                  
 441   2              /*  40004  同步状态设置                   */
 442   2              case 0x03:                                         
 443   2                  qdc_info.board_temp = sata.RX1_buf[4];     
 444   2                  qdc_info.board_switch = sata.RX1_buf[5];   
 445   2                  eeprom_data_record();
 446   2                  break;
 447   2      
 448   2              /*  40005  工作模式设置                   */
 449   2              case 0x04:                                         
 450   2                  qdc_info.inksac_switch = sata.RX1_buf[5]; 
 451   2                  eeprom_data_record();
 452   2                  break;
 453   2      
 454   2              /*  40006  报警温度设置                   */
 455   2              case 0x05:                                         
 456   2                  qdc_info.cir_switch = (sata.RX1_buf[5] & 0x07);     
 457   2                  qdc_info.cir_start_time = (sata.RX1_buf[5] >> 3) | ((sata.RX1_buf[4] & 0x01) << 5);
 458   2                  qdc_info.cir_stop_time = sata.RX1_buf[4] >> 1;
 459   2                  
 460   2                  break;
 461   2      
 462   2              case 0x06:  
 463   2                  qdc_info.stir_switch = (sata.RX1_buf[5] & 0x07);     
 464   2                  qdc_info.stir_start_time = (sata.RX1_buf[5] >> 3) | ((sata.RX1_buf[4] & 0x01) << 5);
 465   2                  qdc_info.stir_stop_time = sata.RX1_buf[4] >> 1;
 466   2                  eeprom_data_record();
 467   2      
 468   2                  break;
 469   2                  
 470   2              default:
 471   2                  break;   
 472   2          }
 473   1          
 474   1          slave_to_master_Sata(0x06,8);
 475   1          
 476   1      }
 477          
 478          
 479          /**
 480           * @brief       写单个输出寄存器  06
 481           *
 482           * @param   void
 483           *
 484           * @return  void 
 485          **/
 486          void Modbus_Fun6_Sata( void )
 487          {
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/18/2025 12:14:17 PAGE 9   

 488   1          switch (sata.RX1_buf[3])
 489   1          {
 490   2              /*  40001  胶辊加热                 */
 491   2              case 0x00:                  
 492   2                  qdc_info.roller_temp = sata.RX1_buf[4];
 493   2                  qdc_info.roller_switch = sata.RX1_buf[5];
 494   2                  rubber_roller_ctrl(qdc_info.roller_switch);
 495   2      
 496   2                  slave_to_master_Sata(0x06,8);
 497   2                  eeprom_data_record();
 498   2      
 499   2                  break;
 500   2      
 501   2              /*  40002  LED 开关状态设置                          */
 502   2              case 0x01:        
 503   2                  qdc_info.fan_level = sata.RX1_buf[5];                                 
 504   2                  led_ctrl(sata.RX1_buf[5]);
 505   2      
 506   2                  slave_to_master_Sata(0x06,8);
 507   2                  eeprom_data_record();    
 508   2      
 509   2                  break;
 510   2      
 511   2              /*  40003 风扇                          */
 512   2              case 0x02: 
 513   2                  qdc_info.fan_level = sata.RX1_buf[5];                                     
 514   2                  fan_ctrl(qdc_info.fan_level);
 515   2      
 516   2                  slave_to_master_Sata(0x06,8);
 517   2                  eeprom_data_record();
 518   2      
 519   2                  break;  
 520   2                  
 521   2              /*  40004  底板加热                   */
 522   2              case 0x03:            
 523   2                  send_to_EB_06(0x03,sata.RX1_buf[4],sata.RX1_buf[5]);   
 524   2      
 525   2                  break;
 526   2      
 527   2              /*  40005  墨囊加热                   */
 528   2              case 0x04:                   
 529   2                  send_to_EB_06(0x04,0x00,sata.RX1_buf[5]);                      
 530   2      
 531   2      
 532   2                  break;
 533   2      
 534   2              /*  40006  循环控制                   */
 535   2              case 0x05:                
 536   2                  send_to_EB_06(0x05,sata.RX1_buf[4],sata.RX1_buf[5]);                       
 537   2      
 538   2                  break;
 539   2              /*  40007  搅拌控制                   */
 540   2              case 0x06:       
 541   2                  send_to_EB_06(0x06,sata.RX1_buf[4],sata.RX1_buf[5]);                                          
 542   2          
 543   2                  break;
 544   2      
 545   2              /*  40008  缺墨延时时间                   */
 546   2              case 0x07:                                         
 547   2                  qdc_info.ink_out_time = sata.RX1_buf[5];  
 548   2      
 549   2                  slave_to_master_Sata(0x06,8);
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/18/2025 12:14:17 PAGE 10  

 550   2                  eeprom_data_record();
 551   2      
 552   2                  break;
 553   2      
 554   2              default:
 555   2                  break;   
 556   2          }
 557   1      }
 558          
 559          /**
 560           * @brief       写多个输出寄存器  16
 561           *
 562           * @param   void
 563           *
 564           * @return  void 
 565          **/
 566          void Modbus_Fun16_485( void )
 567          {
 568   1          uint16_t i;
 569   1      
 570   1          modbus.rcv_value_addr = 7;                  //DATA1 H位置
 571   1          modbus.byte_cnt   = rs485.RX4_buf[6];
 572   1          modbus.start_addr = rs485.RX4_buf[2]<<8 | rs485.RX4_buf[3];
 573   1      
 574   1          
 575   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++)
 576   1          {
 577   2              modbus.byte_info_H = rs485.RX4_buf[modbus.rcv_value_addr];
 578   2              modbus.byte_info_L = rs485.RX4_buf[modbus.rcv_value_addr + 1];
 579   2              switch (i)
 580   2              {
 581   3                  /*  40001  风速设置                 */
 582   3                  case 0x00:
 583   3      
 584   3                      break;
 585   3                  
 586   3                  /*  40002  LED 开关状态设置                          */
 587   3                  case 0x01:
 588   3                      led_ctrl(modbus.byte_info_L);
 589   3      
 590   3                      eeprom.led_info = modbus.byte_info_L;
 591   3      
 592   3                      break;
 593   3      
 594   3                  /*  40003 三路220V输出使能设置                          */
 595   3                  case 0x02:
 596   3      
 597   3      
 598   3                      break;
 599   3      
 600   3                  
 601   3                  /*  40004  同步状态设置                   */
 602   3                  case 0x03:
 603   3      
 604   3      
 605   3                      break;
 606   3      
 607   3                  /*  40005  工作模式设置                   */
 608   3                  case 0x04:                                         
 609   3      
 610   3      
 611   3                      break;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/18/2025 12:14:17 PAGE 11  

 612   3      
 613   3                  /*  40006  报警温度设置                   */
 614   3                  case 0x05:                                         
 615   3      
 616   3                      
 617   3                      break;
 618   3                      
 619   3                  default:
 620   3                      break;
 621   3              }
 622   2              modbus.rcv_value_addr += 2;         //从Value1_H →→ 从Value2_H
 623   2          }
 624   1      
 625   1          slave_to_master_485(0x10,8);
 626   1      
 627   1          eeprom_data_record();                      //记录更改后的值
 628   1      }
 629          
 630          
 631          /**
 632           * @brief       写多个输出寄存器  16
 633           *
 634           * @param   void
 635           *
 636           * @return  void 
 637          **/
 638          void Modbus_Fun16_Sata( void )
 639          {
 640   1          uint16_t i;
 641   1      
 642   1          modbus.rcv_value_addr = 7;                  //DATA1 H位置
 643   1          modbus.byte_cnt   = sata.RX1_buf[6];
 644   1          modbus.start_addr = sata.RX1_buf[2]<<8 |sata.RX1_buf[3];
 645   1      
 646   1          
 647   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++)
 648   1          {
 649   2              modbus.byte_info_H = sata.RX1_buf[modbus.rcv_value_addr];
 650   2              modbus.byte_info_L = sata.RX1_buf[modbus.rcv_value_addr + 1];
 651   2              switch (i)
 652   2              {
 653   3                  /*  40001  风速设置                 */
 654   3                  case 0x00:
 655   3                      qdc_info.roller_temp = sata.RX1_buf[4];
 656   3                      qdc_info.roller_switch = sata.RX1_buf[5];
 657   3                      rubber_roller_ctrl(qdc_info.roller_switch);
 658   3      
 659   3                      slave_to_master_Sata(0x06,8);
 660   3                      eeprom_data_record();
 661   3      
 662   3                      break;
 663   3                  
 664   3                  /*  40002  LED 开关状态设置                          */
 665   3                  case 0x01:
 666   3                      qdc_info.fan_level = sata.RX1_buf[5];                                 
 667   3                      led_ctrl(sata.RX1_buf[5]);
 668   3      
 669   3                      slave_to_master_Sata(0x06,8);
 670   3                      eeprom_data_record();     
 671   3      
 672   3                      break;
 673   3      
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/18/2025 12:14:17 PAGE 12  

 674   3                  /*  40003 三路220V输出使能设置                          */
 675   3                  case 0x02:
 676   3                      qdc_info.fan_level = sata.RX1_buf[5];                                     
 677   3                      fan_ctrl(qdc_info.fan_level);
 678   3      
 679   3                      slave_to_master_Sata(0x06,8);
 680   3                      eeprom_data_record();
 681   3      
 682   3                      break;
 683   3      
 684   3                  
 685   3                  /*  40004  同步状态设置                   */
 686   3                  case 0x03:
 687   3      
 688   3      
 689   3                      break;
 690   3      
 691   3                  /*  40005  工作模式设置                   */
 692   3                  case 0x04:                                         
 693   3      
 694   3      
 695   3                      break;
 696   3      
 697   3                  /*  40006  报警温度设置                   */
 698   3                  case 0x05:                                         
 699   3      
 700   3                      
 701   3                      break;
 702   3                      
 703   3                  default:
 704   3                      break;
 705   3              }
 706   2              modbus.rcv_value_addr += 2;         //从Value1_H →→ 从Value2_H
 707   2          }
 708   1      
 709   1          slave_to_master_Sata(0x10,8);
 710   1      
 711   1          //eeprom_data_record();                      //记录更改后的值
 712   1      }
 713          
 714          /**
 715           * @brief       从机回复主机
 716           *  
 717           * @param   code_num:功能码       
 718           * @param   length:数据长度        
 719           * 
 720            @return  crc16:crc校验的值 2byte
 721           */
 722          void slave_to_master_485(uint8_t code_num,uint8_t length)
 723          {
 724   1          uint16_t crc;
 725   1      
 726   1          switch (code_num)
 727   1          {
 728   2              case 0x03:
 729   2                  crc = MODBUS_CRC16(rs485.TX4_buf,length);
 730   2      
 731   2                  rs485.TX4_buf[length+1] = crc;                 //CRC H
 732   2                  rs485.TX4_buf[length] = crc>>8;            //CRC L
 733   2      
 734   2                  rs485.TX4_send_bytelength = length + 2;
 735   2                  
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/18/2025 12:14:17 PAGE 13  

 736   2                  break;
 737   2              case 0x04:
 738   2                  crc = MODBUS_CRC16(rs485.TX4_buf,length);
 739   2      
 740   2                  rs485.TX4_buf[length+1] = crc;                 //CRC H
 741   2                  rs485.TX4_buf[length] = crc>>8;            //CRC L
 742   2      
 743   2                  rs485.TX4_send_bytelength = length + 2;
 744   2                  
 745   2                  break;    
 746   2      
 747   2              case 0x06:
 748   2                  memcpy(rs485.TX4_buf,rs485.RX4_buf,8);
 749   2      
 750   2                  rs485.TX4_send_bytelength = length;
 751   2                  
 752   2                  break;   
 753   2      
 754   2              case 0x10:
 755   2                  memcpy(rs485.TX4_buf,rs485.RX4_buf,6);
 756   2              
 757   2                  crc = MODBUS_CRC16(rs485.TX4_buf,6);
 758   2      
 759   2                  rs485.TX4_buf[7] = crc;                 //CRC H
 760   2                  rs485.TX4_buf[6] = crc>>8;              //CRC L
 761   2              
 762   2                  rs485.TX4_send_bytelength = length;
 763   2                  
 764   2                  break;         
 765   2      
 766   2              default:
 767   2                  break;
 768   2          }
 769   1      
 770   1          DR_485 = 1;                                 //485可以发送
 771   1          delay_ms(2);
 772   1          S4CON |= S4TI;                              //开始发送
 773   1          delay_ms(1);
 774   1      }
 775          
 776          
 777          /**
 778           * @brief       从机回复主机
 779           *  
 780           * @param   code_num:功能码       
 781           * @param   length:数据长度        
 782           * 
 783            @return  crc16:crc校验的值 2byte
 784           */
 785          void slave_to_master_Sata(uint8_t code_num,uint8_t length)
 786          {
 787   1          uint16_t crc;
 788   1      
 789   1          switch (code_num)
 790   1          {
 791   2              case 0x03:
 792   2                  crc = MODBUS_CRC16(sata.TX1_buf,length);
 793   2      
 794   2                  sata.TX1_buf[length+1] = crc>>8;                 //CRC H
 795   2                  sata.TX1_buf[length] = crc;            //CRC L
 796   2      
 797   2                  sata.TX1_send_bytelength = length + 2;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/18/2025 12:14:17 PAGE 14  

 798   2                  
 799   2                  break;
 800   2              case 0x04:
 801   2                  crc = MODBUS_CRC16(sata.TX1_buf,length);
 802   2      
 803   2                  sata.TX1_buf[length+1] = crc>>8;                 //CRC H
 804   2                  sata.TX1_buf[length] = crc;            //CRC L
 805   2      
 806   2                  sata.TX1_send_bytelength = length + 2;
 807   2                  
 808   2                  break;    
 809   2      
 810   2              case 0x06:
 811   2                  memcpy(sata.TX1_buf,sata.RX1_buf,8);
 812   2      
 813   2                  sata.TX1_send_bytelength = length;
 814   2                  
 815   2                  break;   
 816   2      
 817   2              case 0x10:
 818   2                  memcpy(sata.TX1_buf,sata.RX1_buf,6);
 819   2              
 820   2                  crc = MODBUS_CRC16(sata.TX1_buf,6);
 821   2      
 822   2                  sata.TX1_buf[6] = crc;                 //CRC H
 823   2                  sata.TX1_buf[6] = crc>>8;              //CRC L
 824   2      
 825   2                  sata.TX1_send_bytelength = length;
 826   2      
 827   2                  break;         
 828   2      
 829   2              default:
 830   2                  break;
 831   2          }
 832   1          TI  = 1;                              //开始发送
 833   1          delay_ms(1);
 834   1      }
 835          
 836          /**
 837           * @brief       crc校验函数
 838           * 
 839           * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
 840           * @param   length:数据长度           
 841           * 
 842            @return  crc16:crc校验的值 2byte
 843           */
 844          uint16_t MODBUS_CRC16(uint8_t *buf, uint8_t length)
 845          {
 846   1              uint8_t i;
 847   1              uint16_t        crc16;
 848   1      
 849   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
 850   1              crc16 = 0xffff; 
 851   1      
 852   1              do
 853   1              {
 854   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */    
             -    
 855   2                      crc16 ^= (uint16_t)*buf;                //
 856   2                      for(i=0; i<8; i++)              
 857   2                      {
 858   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/18/2025 12:14:17 PAGE 15  

             -位 再异或0xA001    */
 859   3                              if(crc16 & 1)
 860   3                  {
 861   4                      crc16 = (crc16 >> 1) ^ 0xA001;
 862   4                  }
 863   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位                */
 864   3                  else
 865   3                  {
 866   4                      crc16 >>= 1;
 867   4                  }           
 868   3                      }
 869   2                      buf++;
 870   2              }while(--length != 0);
 871   1      
 872   1              return  (crc16);
 873   1      }
 874          
 875          void waste_ink_scan( void )
 876          {
 877   1              if( WASTE_INK == 0 )
 878   1              {
 879   2                  qdc_info.waste_ink = 0;
 880   2              }else
 881   1              {
 882   2                  qdc_info.waste_ink = 1;
 883   2              }
 884   1      }
 885          
 886          void send_to_EB_16( void )
 887          {
 888   1          uint8_t send_buf[17];
 889   1         uint16_t crc;
 890   1      
 891   1         send_buf[0] = 0xEB;
 892   1         send_buf[1] = 0x10;
 893   1         send_buf[2] = 0x00;
 894   1         send_buf[3] = 0x00;
 895   1         send_buf[4] = 0x00;
 896   1         send_buf[5] = 0x04;
 897   1         send_buf[6] = 0x08;
 898   1      
 899   1         send_buf[7] = qdc_info.board_temp;
 900   1         send_buf[8] = qdc_info.board_switch;
 901   1      
 902   1         send_buf[9] = 0x00;
 903   1         send_buf[10] = qdc_info.inksac_switch;
 904   1      
 905   1         send_buf[11] = (qdc_info.cir_stop_time << 1) | (qdc_info.cir_start_time >> 5);
 906   1         send_buf[12] = qdc_info.cir_switch | (qdc_info.cir_start_time << 3);
 907   1      
 908   1         send_buf[13] = (qdc_info.stir_stop_time << 1) | (qdc_info.stir_start_time >> 5);
 909   1         send_buf[14] = qdc_info.stir_switch | (qdc_info.stir_start_time << 3);
 910   1      
 911   1         crc = MODBUS_CRC16(send_buf,15);
 912   1      
 913   1         send_buf[15] = crc>>8;
 914   1         send_buf[16] = crc;
 915   1      
 916   1         memcpy(rs485.TX4_buf,send_buf,17);
 917   1         
 918   1         rs485.TX4_send_bytelength = 17;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/18/2025 12:14:17 PAGE 16  

 919   1         DR_485 = 1;                                 //485可以发送
 920   1         delay_ms(2);
 921   1         S4CON |= S4TI;                              //开始发送
 922   1         delay_ms(1);
 923   1      }
 924          
 925          
 926          void send_to_EB_06( uint8_t addr, uint8_t val_H, uint8_t val_L)
 927          {
 928   1          uint8_t send_buf[8];
 929   1          uint16_t crc;
 930   1      
 931   1          send_buf[0] = 0xEB;
 932   1          send_buf[1] = 0x06;
 933   1          send_buf[2] = 0x00;
 934   1          send_buf[3] = addr;
 935   1          send_buf[4] = val_H;
 936   1          send_buf[5] = val_L;
 937   1      
 938   1          crc = MODBUS_CRC16(send_buf,6);
 939   1      
 940   1          send_buf[6] = crc>>8;
 941   1          send_buf[7] = crc;
 942   1      
 943   1          memcpy(rs485.TX4_buf,send_buf,8);
 944   1      
 945   1          rs485.TX4_send_bytelength = 8;
 946   1          DR_485 = 1;                                 //485可以发送
 947   1          delay_ms(2);
 948   1          S4CON |= S4TI;                              //开始发送
 949   1          delay_ms(1);
 950   1      }
 951          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2588    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7      40
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
