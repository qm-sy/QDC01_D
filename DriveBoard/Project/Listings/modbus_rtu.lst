C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/19/2025 16:23:09 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODBUS_RTU
OBJECT MODULE PLACED IN ..\Output\modbus_rtu.obj
COMPILER INVOKED BY: D:\APP\Keil_v5\C51\BIN\C51.EXE ..\Emembed\Src\modbus_rtu.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..
                    -\BSP\Inc;..\Core\Inc;..\Driver;..\Emembed\Inc;..\SYSTEM\Inc) DEBUG OBJECTEXTEND PRINT(.\Listings\modbus_rtu.lst) OBJECT(
                    -..\Output\modbus_rtu.obj)

line level    source

   1          #include "modbus_rtu.h"
   2          
   3          MODBIS_INFO modbus;
   4          
   5          /**
   6           * @brief       modbus_rtu  无奇偶校验
   7           *
   8           * @param   void
   9           *
  10           * @return  void 
  11          **/
  12          void Modbus_Event_485( void )
  13          {
  14   1          uint16_t crc,rccrc;
  15   1          
  16   1          /*1.接收完毕                                           */
  17   1          if( rs485.RX4_rev_end_Flag == 1 )
  18   1          {
  19   2              /*2.清空接收完毕标志位                              */    
  20   2              rs485.RX4_rev_end_Flag = 0;
  21   2      
  22   2              /*3.CRC校验                                         */
  23   2              crc = MODBUS_CRC16(rs485.RX4_buf, rs485.RX4_rev_cnt-2);
  24   2              rccrc = (rs485.RX4_buf[rs485.RX4_rev_cnt-1]) | (rs485.RX4_buf[rs485.RX4_rev_cnt-2]<<8);
  25   2      
  26   2              /*4.清空接收计数                                    */
  27   2              rs485.RX4_rev_cnt = 0; 
  28   2      
  29   2              /*5.CRC校验通过，进行地址域校验                      */
  30   2              if( crc == rccrc )
  31   2              {
  32   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  33   3                  if( rs485.RX4_buf[0] == ADDR_485 )
  34   3                  {
  35   4                      switch ( rs485.RX4_buf[1] )
  36   4                      {
  37   5                          case 0x03:
  38   5                              Modbus_Fun3_485();
  39   5                              break;
  40   5      
  41   5                          case 0x04:
  42   5                              Modbus_Fun4_485();
  43   5                              break;
  44   5      
  45   5                          case 0x06:
  46   5                              Modbus_Fun6_485();
  47   5                              break;  
  48   5      
  49   5                          case 0x10:  
  50   5                              Modbus_Fun16_485();
  51   5      
  52   5                          default:
  53   5                              break;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/19/2025 16:23:09 PAGE 2   

  54   5                      }
  55   4                  }
  56   3              }
  57   2          }
  58   1      }
  59          
  60          
  61          /**
  62           * @brief       modbus_rtu  无奇偶校验
  63           *
  64           * @param   void
  65           *
  66           * @return  void 
  67          **/
  68          void Modbus_Event_Sata( void )
  69          {
  70   1          uint16_t crc,rccrc;
  71   1          
  72   1          /*1.接收完毕                                           */
  73   1          if( sata.RX1_rev_end_Flag == 1 )
  74   1          {
  75   2              /*2.清空接收完毕标志位                              */    
  76   2              sata.RX1_rev_end_Flag = 0;
  77   2      
  78   2              /*3.CRC校验                                         */
  79   2              crc = MODBUS_CRC16(sata.RX1_buf, sata.RX1_rev_cnt-2);
  80   2              rccrc = (sata.RX1_buf[sata.RX1_rev_cnt-2]) | (sata.RX1_buf[sata.RX1_rev_cnt-1]<<8);
  81   2      
  82   2              /*4.清空接收计数                                    */
  83   2              sata.RX1_rev_cnt = 0; 
  84   2      
  85   2              /*5.CRC校验通过，进行地址域校验                      */
  86   2              if( crc == rccrc )
  87   2              {
  88   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
  89   3                  if( sata.RX1_buf[0] == ADDR_SATA )
  90   3                  {
  91   4                      switch ( sata.RX1_buf[1] )
  92   4                      {
  93   5                          case 0x03:
  94   5                              Modbus_Fun3_Sata();
  95   5      
  96   5                              break;
  97   5      
  98   5                          case 0x04:
  99   5                              Modbus_Fun4_Sata();
 100   5                              
 101   5                              break;
 102   5      
 103   5                          case 0x06:
 104   5                              Modbus_Fun6_Sata();
 105   5      
 106   5                              break;  
 107   5      
 108   5                          case 0x10:  
 109   5                              Modbus_Fun16_Sata();
 110   5      
 111   5                          default:
 112   5                              break;
 113   5                      }
 114   4                  }
 115   3              }
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/19/2025 16:23:09 PAGE 3   

 116   2          }
 117   1      }
 118          
 119          /**
 120           * @brief       读输入寄存器  03
 121           *
 122           * @param   void
 123           *
 124           * @return  void 
 125          **/
 126          void Modbus_Fun3_485( void )
 127          {
 128   1          uint16_t i;
 129   1      
 130   1          modbus.send_value_addr  = 3;                //DATA1 H 位置
 131   1          modbus.byte_cnt   = (rs485.RX4_buf[4]<<8 | rs485.RX4_buf[5]) *2;
 132   1          modbus.start_addr = rs485.RX4_buf[2]<<8 | rs485.RX4_buf[3];
 133   1      
 134   1          rs485.TX4_buf[0]  = ADDR_485;                //Addr
 135   1          rs485.TX4_buf[1]  = 0x03;                   //Fun
 136   1          rs485.TX4_buf[2]  = modbus.byte_cnt;        //Byte Count
 137   1      
 138   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
 139   1          {
 140   2              /*    每次循环前初始化byte_info                       */
 141   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
 142   2              switch (i)
 143   2              {   
 144   3                  /*  40001 风速查询                     */
 145   3                  case 0x00:
 146   3      
 147   3      
 148   3                      break;
 149   3      
 150   3                  /*  40002 LED开关状态查询                     */    
 151   3                  case 0x01:
 152   3      
 153   3                      break;
 154   3      
 155   3                  /*  40003 3路220V开关使能查询                         */
 156   3                  case 0x02:    
 157   3      
 158   3                      break;
 159   3      
 160   3                  /*  40004 同步状态查询              */
 161   3                  case 0x03:    
 162   3      
 163   3      
 164   3                      break;
 165   3      
 166   3                  /*  40005 工作模式查询                     */
 167   3                  case 0x04:   
 168   3      
 169   3                      break;
 170   3      
 171   3                  /*  40006 报警温度查询                     */
 172   3                  case 5:   
 173   3              
 174   3      
 175   3                      break;
 176   3                  default:
 177   3                      break;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/19/2025 16:23:09 PAGE 4   

 178   3              }
 179   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 180   2              rs485.TX4_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 181   2          }
 182   1          slave_to_master_485(0x03,3 + modbus.byte_cnt);
 183   1      }
 184          
 185          
 186          /**
 187           * @brief       读输入寄存器  03
 188           *
 189           * @param   void
 190           *
 191           * @return  void 
 192          **/
 193          void Modbus_Fun3_Sata( void )
 194          {
 195   1          uint16_t i;
 196   1      
 197   1          modbus.send_value_addr  = 3;                //DATA1 H 位置
 198   1          modbus.byte_cnt   = (sata.RX1_buf[4]<<8 | sata.RX1_buf[5]) *2;
 199   1          modbus.start_addr = sata.RX1_buf[2]<<8 | sata.RX1_buf[3];
 200   1      
 201   1          sata.TX1_buf[0]  = ADDR_SATA;                //Addr
 202   1          sata.TX1_buf[1]  = 0x03;                   //Fun
 203   1          sata.TX1_buf[2]  = modbus.byte_cnt;        //Byte Count
 204   1      
 205   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
 206   1          {
 207   2              /*    每次循环前初始化byte_info                       */
 208   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
 209   2              switch (i)
 210   2              {   
 211   3                  /*  40001 胶辊加热                     */
 212   3                  case 0x00:
 213   3                      modbus.byte_info_H = qdc_info.roller_temp;
 214   3                      modbus.byte_info_L = qdc_info.roller_switch;
 215   3      
 216   3                      break;
 217   3      
 218   3                  /*  40002 LED开关状态查询                     */    
 219   3                  case 0x01:
 220   3                      modbus.byte_info_H = 0x00;
 221   3                      modbus.byte_info_L = qdc_info.led_switch;
 222   3      
 223   3                      break;
 224   3      
 225   3                  /*  40003 风扇                         */
 226   3                  case 0x02:    
 227   3                      modbus.byte_info_H = 0x00;
 228   3                      modbus.byte_info_L = qdc_info.fan_level;
 229   3      
 230   3                      break;
 231   3      
 232   3                  /*  40004 底板加热              */
 233   3                  case 0x03:    
 234   3                      modbus.byte_info_H = qdc_info.board_temp;
 235   3                      modbus.byte_info_L = qdc_info.board_switch;
 236   3      
 237   3                      break;
 238   3      
 239   3                  /*  40005 墨囊加热                     */
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/19/2025 16:23:09 PAGE 5   

 240   3                  case 0x04:   
 241   3                      modbus.byte_info_H = 0x00;
 242   3                      modbus.byte_info_L = qdc_info.inksac_switch;
 243   3      
 244   3                      break;
 245   3      
 246   3                  /*  40006 循环控制                     */
 247   3                  case 0x05:   
 248   3                      modbus.byte_info_H = (qdc_info.cir_stop_time << 1) | (qdc_info.cir_start_time >> 5);
 249   3                      modbus.byte_info_L = qdc_info.cir_switch | (qdc_info.cir_start_time << 3);
 250   3                      
 251   3                      break;
 252   3                  /*  40007 搅拌控制                     */
 253   3                  case 0x06:   
 254   3                      modbus.byte_info_H = (qdc_info.stir_stop_time << 1) | (qdc_info.stir_start_time >> 5);
 255   3                      modbus.byte_info_L = qdc_info.stir_switch | (qdc_info.stir_start_time << 3);
 256   3      
 257   3                      break;
 258   3      
 259   3                  /*  40008  缺墨延时时间                      */
 260   3                  case 0x07:   
 261   3                      modbus.byte_info_H = 0x00;
 262   3                      modbus.byte_info_L = qdc_info.ink_out_time;
 263   3                      
 264   3                      break;
 265   3      
 266   3                  default:
 267   3                      break;
 268   3              }
 269   2              sata.TX1_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 270   2              sata.TX1_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 271   2          }
 272   1          slave_to_master_Sata(0x03,3 + modbus.byte_cnt);
 273   1      }
 274          
 275          /**
 276           * @brief       读输出寄存器  04
 277           *
 278           * @param   void
 279           *
 280           * @return  void 
 281          **/
 282          void Modbus_Fun4_485( void )
 283          {
 284   1      
 285   1      
 286   1          qdc_info.level_info2 = rs485.RX4_buf[3];
 287   1          qdc_info.level_info1 = rs485.RX4_buf[4];
 288   1      
 289   1      
 290   1          /*  30002  NTC3、NTC4温度查询                */
 291   1      
 292   1      
 293   1          /*  30003 温湿度                   */
 294   1      
 295   1          qdc_info.dht11_hum = rs485.RX4_buf[7];
 296   1          qdc_info.dht11_temp = rs485.RX4_buf[8];
 297   1      
 298   1      
 299   1          /*  30004 NTC1 温度                    */
 300   1      
 301   1          qdc_info.ntc1_temp = rs485.RX4_buf[10];
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/19/2025 16:23:09 PAGE 6   

 302   1      
 303   1      }
 304          
 305          
 306          /**
 307           * @brief       读输出寄存器  04
 308           *
 309           * @param   void
 310           *
 311           * @return  void 
 312          **/
 313          void Modbus_Fun4_Sata( void )
 314          {
 315   1          uint16_t i;
 316   1      
 317   1          modbus.send_value_addr  = 3;                 //DATA1 H 位置
 318   1          modbus.byte_cnt   = (sata.RX1_buf[4]<<8 | sata.RX1_buf[5]) *2;
 319   1          modbus.start_addr = sata.RX1_buf[2]<<8 | sata.RX1_buf[3];
 320   1      
 321   1          sata.TX1_buf[0]  = ADDR_SATA;                //Addr
 322   1          sata.TX1_buf[1]  = 0x04;                   //Fun
 323   1          sata.TX1_buf[2]  = modbus.byte_cnt;        //Byte Count
 324   1      
 325   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++ )
 326   1          {
 327   2              /*    每次循环前初始化byte_info                       */
 328   2              modbus.byte_info_H = modbus.byte_info_L = 0X00;
 329   2              switch (i)
 330   2              {
 331   3                  /*  30001  1~7通道液位信息                           */
 332   3                  case 0x00:
 333   3                      modbus.byte_info_H = qdc_info.level_info2;
 334   3                      modbus.byte_info_L = qdc_info.level_info1;
 335   3      
 336   3                      break;
 337   3      
 338   3                  /*  30002 废墨液位信息                 */
 339   3                  case 0x01:
 340   3                      waste_ink_scan();
 341   3                      modbus.byte_info_H = 0x00;
 342   3                      modbus.byte_info_L = qdc_info.waste_ink;
 343   3      
 344   3                      break;
 345   3      
 346   3                  /*  30003 环境温湿度查询                   */
 347   3                  case 0x02:
 348   3                      modbus.byte_info_H = qdc_info.dht11_hum;
 349   3                      modbus.byte_info_L = qdc_info.dht11_temp;
 350   3      
 351   3                      break;
 352   3      
 353   3                  /*  30004 NTC温度                  */
 354   3                  case 0x03:
 355   3                      modbus.byte_info_H = 0x00;
 356   3                      modbus.byte_info_L = qdc_info.ntc1_temp;
 357   3      
 358   3                      break;
 359   3                      
 360   3                  /*  30005 热电堆温度                   */
 361   3                  case 0x04:
 362   3                      modbus.byte_info_H = 0x00;
 363   3                      modbus.byte_info_L = 25;
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/19/2025 16:23:09 PAGE 7   

 364   3                      
 365   3                      break;
 366   3      
 367   3                  default:
 368   3                      break;
 369   3              }
 370   2              sata.TX1_buf[modbus.send_value_addr++] = modbus.byte_info_H;
 371   2              sata.TX1_buf[modbus.send_value_addr++] = modbus.byte_info_L;
 372   2          }
 373   1          slave_to_master_Sata(0x04,3 + modbus.byte_cnt);
 374   1      }
 375          
 376          /**
 377           * @brief       写单个输出寄存器  06
 378           *
 379           * @param   void
 380           *
 381           * @return  void 
 382          **/
 383          void Modbus_Fun6_485( void )
 384          {
 385   1          switch (rs485.RX4_buf[3])
 386   1          {
 387   2              /*  40001  风速设置                 */
 388   2              case 0x00:                  
 389   2      
 390   2                  break;
 391   2      
 392   2              /*  40002  LED 开关状态设置                          */
 393   2              case 0x01:                                         
 394   2      
 395   2      
 396   2                  break;
 397   2      
 398   2              /*  40003 三路220V输出使能设置                          */
 399   2              case 0x02:                                         
 400   2      
 401   2                  break;  
 402   2                  
 403   2              /*  40004  同步状态设置                   */
 404   2              case 0x03:                                         
 405   2                  qdc_info.board_temp = sata.RX1_buf[4];     
 406   2                  qdc_info.board_switch = sata.RX1_buf[5];   
 407   2                  eeprom_data_record();
 408   2                  break;
 409   2      
 410   2              /*  40005  工作模式设置                   */
 411   2              case 0x04:                                         
 412   2                  qdc_info.inksac_switch = sata.RX1_buf[5]; 
 413   2                  eeprom_data_record();
 414   2                  break;
 415   2      
 416   2              /*  40006  报警温度设置                   */
 417   2              case 0x05:                                         
 418   2                  qdc_info.cir_switch = (sata.RX1_buf[5] & 0x07);     
 419   2                  qdc_info.cir_start_time = (sata.RX1_buf[5] >> 3) | ((sata.RX1_buf[4] & 0x01) << 5);
 420   2                  qdc_info.cir_stop_time = sata.RX1_buf[4] >> 1;
 421   2                  
 422   2                  break;
 423   2      
 424   2              case 0x06:  
 425   2                  qdc_info.stir_switch = (sata.RX1_buf[5] & 0x07);     
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/19/2025 16:23:09 PAGE 8   

 426   2                  qdc_info.stir_start_time = (sata.RX1_buf[5] >> 3) | ((sata.RX1_buf[4] & 0x01) << 5);
 427   2                  qdc_info.stir_stop_time = sata.RX1_buf[4] >> 1;
 428   2                  eeprom_data_record();
 429   2      
 430   2                  break;
 431   2                  
 432   2              case 0x07: 
 433   2                  qdc_info.ink_out_time = sata.RX1_buf[5];  
 434   2                  eeprom_data_record();
 435   2      
 436   2              default:
 437   2                  break;   
 438   2          }
 439   1          
 440   1          slave_to_master_Sata(0x06,8);
 441   1          
 442   1      }
 443          
 444          
 445          /**
 446           * @brief       写单个输出寄存器  06
 447           *
 448           * @param   void
 449           *
 450           * @return  void 
 451          **/
 452          void Modbus_Fun6_Sata( void )
 453          {
 454   1          switch (sata.RX1_buf[3])
 455   1          {
 456   2              /*  40001  胶辊加热                 */
 457   2              case 0x00:                  
 458   2                  qdc_info.roller_temp = sata.RX1_buf[4];
 459   2                  qdc_info.roller_switch = sata.RX1_buf[5];
 460   2                  rubber_roller_ctrl(qdc_info.roller_switch);
 461   2      
 462   2                  slave_to_master_Sata(0x06,8);
 463   2                  eeprom_data_record();
 464   2      
 465   2                  break;
 466   2      
 467   2              /*  40002  LED 开关状态设置                          */
 468   2              case 0x01:        
 469   2                  qdc_info.fan_level = sata.RX1_buf[5];                                 
 470   2                  led_ctrl(sata.RX1_buf[5]);
 471   2      
 472   2                  slave_to_master_Sata(0x06,8);
 473   2                  eeprom_data_record();    
 474   2      
 475   2                  break;
 476   2      
 477   2              /*  40003 风扇                          */
 478   2              case 0x02: 
 479   2                  qdc_info.fan_level = sata.RX1_buf[5];                                     
 480   2                  fan_ctrl(qdc_info.fan_level);
 481   2      
 482   2                  slave_to_master_Sata(0x06,8);
 483   2                  eeprom_data_record();
 484   2      
 485   2                  break;  
 486   2                  
 487   2              /*  40004  底板加热                   */
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/19/2025 16:23:09 PAGE 9   

 488   2              case 0x03:            
 489   2                  send_to_EB_06(0x03,sata.RX1_buf[4],sata.RX1_buf[5]);   
 490   2      
 491   2                  break;
 492   2      
 493   2              /*  40005  墨囊加热                   */
 494   2              case 0x04:                   
 495   2                  send_to_EB_06(0x04,0x00,sata.RX1_buf[5]);                      
 496   2      
 497   2      
 498   2                  break;
 499   2      
 500   2              /*  40006  循环控制                   */
 501   2              case 0x05:                
 502   2                  send_to_EB_06(0x05,sata.RX1_buf[4],sata.RX1_buf[5]);                       
 503   2      
 504   2                  break;
 505   2              /*  40007  搅拌控制                   */
 506   2              case 0x06:       
 507   2                  send_to_EB_06(0x06,sata.RX1_buf[4],sata.RX1_buf[5]);                                          
 508   2          
 509   2                  break;
 510   2      
 511   2              /*  40008  缺墨延时时间                   */
 512   2              case 0x07:                             
 513   2                  send_to_EB_06(0x07,0x00,sata.RX1_buf[5]);                 
 514   2      
 515   2                  break;
 516   2      
 517   2              default:
 518   2                  break;   
 519   2          }
 520   1      }
 521          
 522          /**
 523           * @brief       写多个输出寄存器  16
 524           *
 525           * @param   void
 526           *
 527           * @return  void 
 528          **/
 529          void Modbus_Fun16_485( void )
 530          {
 531   1          rs485.connect_flag = 1;
 532   1      }
 533          
 534          
 535          /**
 536           * @brief       写多个输出寄存器  16
 537           *
 538           * @param   void
 539           *
 540           * @return  void 
 541          **/
 542          void Modbus_Fun16_Sata( void )
 543          {
 544   1          uint16_t i;
 545   1      
 546   1          modbus.rcv_value_addr = 7;                  //DATA1 H位置
 547   1          modbus.byte_cnt   = sata.RX1_buf[6];
 548   1          modbus.start_addr = sata.RX1_buf[2]<<8 |sata.RX1_buf[3];
 549   1      
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/19/2025 16:23:09 PAGE 10  

 550   1          
 551   1          for( i = modbus.start_addr; i < modbus.start_addr + modbus.byte_cnt/2; i++)
 552   1          {
 553   2              modbus.byte_info_H = sata.RX1_buf[modbus.rcv_value_addr];
 554   2              modbus.byte_info_L = sata.RX1_buf[modbus.rcv_value_addr + 1];
 555   2              switch (i)
 556   2              {
 557   3                  /*  40001  风速设置                 */
 558   3                  case 0x00:
 559   3                      qdc_info.roller_temp = sata.RX1_buf[4];
 560   3                      qdc_info.roller_switch = sata.RX1_buf[5];
 561   3                      rubber_roller_ctrl(qdc_info.roller_switch);
 562   3      
 563   3                      slave_to_master_Sata(0x06,8);
 564   3                      eeprom_data_record();
 565   3      
 566   3                      break;
 567   3                  
 568   3                  /*  40002  LED 开关状态设置                          */
 569   3                  case 0x01:
 570   3                      qdc_info.fan_level = sata.RX1_buf[5];                                 
 571   3                      led_ctrl(sata.RX1_buf[5]);
 572   3      
 573   3                      slave_to_master_Sata(0x06,8);
 574   3                      eeprom_data_record();     
 575   3      
 576   3                      break;
 577   3      
 578   3                  /*  40003 三路220V输出使能设置                          */
 579   3                  case 0x02:
 580   3                      qdc_info.fan_level = sata.RX1_buf[5];                                     
 581   3                      fan_ctrl(qdc_info.fan_level);
 582   3      
 583   3                      slave_to_master_Sata(0x06,8);
 584   3                      eeprom_data_record();
 585   3      
 586   3                      break;
 587   3      
 588   3                  
 589   3                  /*  40004  同步状态设置                   */
 590   3                  case 0x03:
 591   3      
 592   3      
 593   3                      break;
 594   3      
 595   3                  /*  40005  工作模式设置                   */
 596   3                  case 0x04:                                         
 597   3      
 598   3      
 599   3                      break;
 600   3      
 601   3                  /*  40006  报警温度设置                   */
 602   3                  case 0x05:                                         
 603   3      
 604   3                      
 605   3                      break;
 606   3                      
 607   3                  default:
 608   3                      break;
 609   3              }
 610   2              modbus.rcv_value_addr += 2;         //从Value1_H →→ 从Value2_H
 611   2          }
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/19/2025 16:23:09 PAGE 11  

 612   1      
 613   1          slave_to_master_Sata(0x10,8);
 614   1      
 615   1          //eeprom_data_record();                      //记录更改后的值
 616   1      }
 617          
 618          /**
 619           * @brief       从机回复主机
 620           *  
 621           * @param   code_num:功能码       
 622           * @param   length:数据长度        
 623           * 
 624            @return  crc16:crc校验的值 2byte
 625           */
 626          void slave_to_master_485(uint8_t code_num,uint8_t length)
 627          {
 628   1          uint16_t crc;
 629   1      
 630   1          switch (code_num)
 631   1          {
 632   2              case 0x03:
 633   2                  crc = MODBUS_CRC16(rs485.TX4_buf,length);
 634   2      
 635   2                  rs485.TX4_buf[length+1] = crc;                 //CRC H
 636   2                  rs485.TX4_buf[length] = crc>>8;            //CRC L
 637   2      
 638   2                  rs485.TX4_send_bytelength = length + 2;
 639   2                  
 640   2                  break;
 641   2              case 0x04:
 642   2                  crc = MODBUS_CRC16(rs485.TX4_buf,length);
 643   2      
 644   2                  rs485.TX4_buf[length+1] = crc;                 //CRC H
 645   2                  rs485.TX4_buf[length] = crc>>8;            //CRC L
 646   2      
 647   2                  rs485.TX4_send_bytelength = length + 2;
 648   2                  
 649   2                  break;    
 650   2      
 651   2              case 0x06:
 652   2                  memcpy(rs485.TX4_buf,rs485.RX4_buf,8);
 653   2      
 654   2                  rs485.TX4_send_bytelength = length;
 655   2                  
 656   2                  break;   
 657   2      
 658   2              case 0x10:
 659   2                  memcpy(rs485.TX4_buf,rs485.RX4_buf,6);
 660   2              
 661   2                  crc = MODBUS_CRC16(rs485.TX4_buf,6);
 662   2      
 663   2                  rs485.TX4_buf[7] = crc;                 //CRC H
 664   2                  rs485.TX4_buf[6] = crc>>8;              //CRC L
 665   2              
 666   2                  rs485.TX4_send_bytelength = length;
 667   2                  
 668   2                  break;         
 669   2      
 670   2              default:
 671   2                  break;
 672   2          }
 673   1      
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/19/2025 16:23:09 PAGE 12  

 674   1          DR_485 = 1;                                 //485可以发送
 675   1          delay_ms(2);
 676   1          S4CON |= S4TI;                              //开始发送
 677   1          delay_ms(1);
 678   1      }
 679          
 680          
 681          /**
 682           * @brief       从机回复主机
 683           *  
 684           * @param   code_num:功能码       
 685           * @param   length:数据长度        
 686           * 
 687            @return  crc16:crc校验的值 2byte
 688           */
 689          void slave_to_master_Sata(uint8_t code_num,uint8_t length)
 690          {
 691   1          uint16_t crc;
 692   1      
 693   1          switch (code_num)
 694   1          {
 695   2              case 0x03:
 696   2                  crc = MODBUS_CRC16(sata.TX1_buf,length);
 697   2      
 698   2                  sata.TX1_buf[length+1] = crc>>8;                 //CRC H
 699   2                  sata.TX1_buf[length] = crc;            //CRC L
 700   2      
 701   2                  sata.TX1_send_bytelength = length + 2;
 702   2                  
 703   2                  break;
 704   2              case 0x04:
 705   2                  crc = MODBUS_CRC16(sata.TX1_buf,length);
 706   2      
 707   2                  sata.TX1_buf[length+1] = crc>>8;                 //CRC H
 708   2                  sata.TX1_buf[length] = crc;            //CRC L
 709   2      
 710   2                  sata.TX1_send_bytelength = length + 2;
 711   2                  
 712   2                  break;    
 713   2      
 714   2              case 0x06:
 715   2                  memcpy(sata.TX1_buf,sata.RX1_buf,8);
 716   2      
 717   2                  sata.TX1_send_bytelength = length;
 718   2                  
 719   2                  break;   
 720   2      
 721   2              case 0x10:
 722   2                  memcpy(sata.TX1_buf,sata.RX1_buf,6);
 723   2              
 724   2                  crc = MODBUS_CRC16(sata.TX1_buf,6);
 725   2      
 726   2                  sata.TX1_buf[6] = crc;                 //CRC H
 727   2                  sata.TX1_buf[6] = crc>>8;              //CRC L
 728   2      
 729   2                  sata.TX1_send_bytelength = length;
 730   2      
 731   2                  break;         
 732   2      
 733   2              default:
 734   2                  break;
 735   2          }
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/19/2025 16:23:09 PAGE 13  

 736   1          TI  = 1;                              //开始发送
 737   1          delay_ms(1);
 738   1      }
 739          
 740          /**
 741           * @brief       crc校验函数
 742           * 
 743           * @param   buf：  Address(1 byte) +Funtion(1 byte) ）+Data(n byte)   
 744           * @param   length:数据长度           
 745           * 
 746            @return  crc16:crc校验的值 2byte
 747           */
 748          uint16_t MODBUS_CRC16(uint8_t *buf, uint8_t length)
 749          {
 750   1              uint8_t i;
 751   1              uint16_t        crc16;
 752   1      
 753   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
 754   1              crc16 = 0xffff; 
 755   1      
 756   1              do
 757   1              {
 758   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */    
             -    
 759   2                      crc16 ^= (uint16_t)*buf;                //
 760   2                      for(i=0; i<8; i++)              
 761   2                      {
 762   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位 再异或0xA001    */
 763   3                              if(crc16 & 1)
 764   3                  {
 765   4                      crc16 = (crc16 >> 1) ^ 0xA001;
 766   4                  }
 767   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位                */
 768   3                  else
 769   3                  {
 770   4                      crc16 >>= 1;
 771   4                  }           
 772   3                      }
 773   2                      buf++;
 774   2              }while(--length != 0);
 775   1      
 776   1              return  (crc16);
 777   1      }
 778          
 779          void waste_ink_scan( void )
 780          {
 781   1              if( WASTE_INK == 0 )
 782   1              {
 783   2                  qdc_info.waste_ink = 0;
 784   2              }else
 785   1              {
 786   2                  qdc_info.waste_ink = 1;
 787   2              }
 788   1      }
 789          
 790          void send_to_EB_16( void )
 791          {
 792   1          uint8_t send_buf[19];
 793   1          uint16_t crc;
 794   1      
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/19/2025 16:23:09 PAGE 14  

 795   1          send_buf[0] = 0xEB;
 796   1          send_buf[1] = 0x10;
 797   1          send_buf[2] = 0x00;
 798   1          send_buf[3] = 0x00;
 799   1          send_buf[4] = 0x00;
 800   1          send_buf[5] = 0x05;
 801   1          send_buf[6] = 0x0a;
 802   1      
 803   1          send_buf[7] = qdc_info.board_temp;
 804   1          send_buf[8] = qdc_info.board_switch;
 805   1      
 806   1          send_buf[9] = 0x00;
 807   1          send_buf[10] = qdc_info.inksac_switch;
 808   1      
 809   1          send_buf[11] = (qdc_info.cir_stop_time << 1) | (qdc_info.cir_start_time >> 5);
 810   1          send_buf[12] = qdc_info.cir_switch | (qdc_info.cir_start_time << 3);
 811   1      
 812   1          send_buf[13] = (qdc_info.stir_stop_time << 1) | (qdc_info.stir_start_time >> 5);
 813   1          send_buf[14] = qdc_info.stir_switch | (qdc_info.stir_start_time << 3);
 814   1      
 815   1          send_buf[15] = 0x00;
 816   1          send_buf[16] = qdc_info.ink_out_time;
 817   1      
 818   1          crc = MODBUS_CRC16(send_buf,17);
 819   1      
 820   1          send_buf[17] = crc>>8;
 821   1          send_buf[18] = crc;
 822   1      
 823   1          memcpy(rs485.TX4_buf,send_buf,19);
 824   1          
 825   1          rs485.TX4_send_bytelength = 19;
 826   1          DR_485 = 1;                                 //485可以发送
 827   1          delay_ms(2);
 828   1          S4CON |= S4TI;                              //开始发送
 829   1          delay_ms(1);
 830   1      }
 831          
 832          
 833          void send_to_EB_06( uint8_t addr, uint8_t val_H, uint8_t val_L)
 834          {
 835   1          uint8_t send_buf[8];
 836   1          uint16_t crc;
 837   1      
 838   1          send_buf[0] = 0xEB;
 839   1          send_buf[1] = 0x06;
 840   1          send_buf[2] = 0x00;
 841   1          send_buf[3] = addr;
 842   1          send_buf[4] = val_H;
 843   1          send_buf[5] = val_L;
 844   1      
 845   1          crc = MODBUS_CRC16(send_buf,6);
 846   1      
 847   1          send_buf[6] = crc>>8;
 848   1          send_buf[7] = crc;
 849   1      
 850   1          memcpy(rs485.TX4_buf,send_buf,8);
 851   1      
 852   1          rs485.TX4_send_bytelength = 8;
 853   1          DR_485 = 1;                                 //485可以发送
 854   1          delay_ms(2);
 855   1          S4CON |= S4TI;                              //开始发送
 856   1          delay_ms(1);
C51 COMPILER V9.60.7.0   MODBUS_RTU                                                        05/19/2025 16:23:09 PAGE 15  

 857   1      }
 858          
 859          void send_to_EB_04( void )
 860          {
 861   1          uint8_t send_buf[8];
 862   1      
 863   1          send_buf[0] = 0xEB;
 864   1          send_buf[1] = 0x04;
 865   1          send_buf[2] = 0x00;
 866   1          send_buf[3] = 0x00;
 867   1          send_buf[4] = 0x00;
 868   1          send_buf[5] = 0x04;
 869   1          send_buf[6] = 0x03;
 870   1          send_buf[7] = 0xE7;
 871   1      
 872   1          memcpy(rs485.TX4_buf,send_buf,8);
 873   1      
 874   1          rs485.TX4_send_bytelength = 8;
 875   1          DR_485 = 1;                                 //485可以发送
 876   1          delay_ms(2);
 877   1          S4CON |= S4TI;                              //开始发送
 878   1          delay_ms(1);
 879   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2412    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7      48
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
