C51 COMPILER V9.60.7.0   MAIN                                                              05/17/2025 23:29:09 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\APP\Keil_STM32\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Project) DEBUG OB
                    -JECTEXTEND PRINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          /*
   2          |P0^0|         |P1^0|Analog1    |P2^0|           |P3^0|RX1        |P4^0|           |P5^0|     
   3          |P0^1|         |P1^1|Analog2    |P2^1|Signal_OUT |P3^1|TX1        |P4^1|AC_Out1    |P5^1|     
   4          |P0^2|RX_485   |P1^2|           |P2^2|PWM        |P3^2|ZERO       |P4^2|AC_Out2    |P5^2|     
   5          |P0^3|TX_485   |P1^3|Signal_IN  |P2^3|LED        |P3^3|           |P4^3|AC_Out3    |P5^3|     
   6          |P0^4|DR_485   |P1^4|NTC1       |P2^4|           |P3^4|           |P4^4|           |P5^4|
   7          |P0^5|         |P1^5|NTC2       |P2^5|           |P3^5|           |P4^5|           |P5^5|             
   8          |P0^6|         |P1^6|NTC3       |P2^6|           |P3^6|FAN_TMEP   |P4^6|           |P5^6|     
   9          |P0^7|         |P1^7|NTC4       |P2^7|           |P3^7|Signal_3V3 |P4^7|Buzzer     |P5^7|     
  10          */ 
  11          
  12          
  13          
  14          
  15          #include "main.h"
  16          
  17          
  18          
  19          
  20          
  21          #define S4TI    0X02
  22          #define S4RI    0X01
  23          
  24          typedef struct 
  25          {
  26              uint8_t     RX4_rev_end_Flag;       //数据包接收完毕标志
  27              uint8_t     TX4_buf[128];           //SBUF TI缓冲区
  28              uint8_t     RX4_buf[128];           //SBUF RI缓冲区
  29              uint8_t     TX4_send_bytelength;    //发送字节数
  30              uint8_t     TX4_send_cnt;           //发送计数
  31              uint16_t    RX4_rev_timeout;        //接收超时
  32              uint8_t     RX4_rev_cnt;            //接收计数
  33              uint8_t     DR_Flag;                //DR
  34          }RS485;
  35          
  36          RS485 rs485;
  37          
  38          void GPIO_Init( void )
  39          {
  40   1          P0M0 = 0x18;    P0M1 = 0x00;        //P0.3、P0.4为推挽输出
  41   1          P1M0 = 0x00;    P1M1 = 0xf8;        //P1.4、P1.5、P1.6、P1.7为高阻输入
  42   1          P2M0 = 0x0e;    P2M1 = 0x00;        //P2.0、P2.1、P2.2、P2.3为推挽输出
  43   1          P3M0 = 0Xc2;    P3M1 = 0X00;        //P3.6、P3.7为推挽输出
  44   1          P4M0 = 0x8e;    P4M1 = 0x00;        //P4.1、P4.2、P4.3、P4.7为推挽输出       
  45   1          P5M0 = 0X00;    P5M1 = 0X00;    
  46   1      }
  47          
  48          void Uart4_Init(void)   //115200bps@11.0592MHz
  49          {
  50   1              S4CON  = 0x10;          //8位数据,可变波特率
  51   1              S4CON |= 0x40;          //串口4选择定时器4为波特率发生器
  52   1      
  53   1              T4T3M |= 0x20;          //定时器时钟1T模式
  54   1      
C51 COMPILER V9.60.7.0   MAIN                                                              05/17/2025 23:29:09 PAGE 2   

  55   1              T4L    = 0xE8;                  //设置定时初始值
  56   1              T4H    = 0xFF;                  //设置定时初始值
  57   1      
  58   1              T4T3M |= 0x80;          //定时器4开始计时
  59   1      
  60   1              IE2   |= 0X10;          //ES4 = 1
  61   1      }
  62          
  63          void Timer0_Init( void )         //1ms@11.0592MHz   16位手动重装载
  64          {
  65   1              AUXR |= 0x80;                    //定时器时钟1T模式
  66   1              TMOD &= 0xF0;                    //设置定时器模式
  67   1              TL0   = 0xCD;                    //设置定时初始值
  68   1              TH0   = 0xD4;            //设置定时初始值
  69   1              TF0   = 0;                               //清除TF0标志
  70   1              TR0   = 1;                               //定时器0开始计时
  71   1      
  72   1          ET0   = 1;                           //打开IE-ET0，TIM0中断
  73   1      }
  74          
  75          void Uart4_Send_Statu_Init( void )
  76          {
  77   1          rs485.RX4_rev_end_Flag = 0;
  78   1          rs485.TX4_buf[128] = 0;
  79   1          rs485.RX4_buf[128] = 0;
  80   1          rs485.TX4_send_bytelength = 0;
  81   1          rs485.TX4_send_cnt = 0;
  82   1          rs485.RX4_rev_timeout = 0;
  83   1          rs485.RX4_rev_cnt = 0;
  84   1          DR_485 = 0;
  85   1      }
  86          
  87          void Uart4_ISR() interrupt 18 
  88          {   
  89   1      
  90   1          /* 1, 检测到S4TI置1，即发送完毕                       */
  91   1          if( S4CON & S4TI )          //
  92   1          {
  93   2              /* 2, 软件将S4TI清零，等待发送标志位重置，可继续发送    */
  94   2              S4CON &= ~S4TI;         
  95   2              
  96   2              /* 3, 依次将TX4_buf中数据送出（写S4BUF操作即为发送）    */
  97   2              if( rs485.TX4_send_bytelength != 0 )
  98   2              {
  99   3                  S4BUF = rs485.TX4_buf[rs485.TX4_send_cnt++];
 100   3                  rs485.TX4_send_bytelength--;
 101   3              }else
 102   2              {
 103   3                  rs485.TX4_send_cnt = 0;
 104   3                  DR_485 = 0;
 105   3              }
 106   2          }
 107   1          
 108   1          /* 1, 检测到S2RI置1，即接收完毕                       */
 109   1          if( S4CON & S4RI )
 110   1          {
 111   2              /* 2, 软件将S2RI清零，等待接收标志位重置，可继续发送    */
 112   2              S4CON &= ~S4RI;
 113   2              /* 3, 判断数据包是否接收完毕                           */
 114   2              if( !rs485.RX4_rev_end_Flag )
 115   2              {
 116   3                  /* 4, 数据包大于RX_buf 则从头计数                  */
C51 COMPILER V9.60.7.0   MAIN                                                              05/17/2025 23:29:09 PAGE 3   

 117   3                  if( rs485.RX4_rev_cnt > 128 )
 118   3                  {
 119   4                      rs485.RX4_rev_cnt = 0;
 120   4                  }
 121   3      
 122   3                  /* 5, 依次将RX4_buf中数据接收（读S2BUF操作即为接收）*/
 123   3                  rs485.RX4_buf[rs485.RX4_rev_cnt] = S4BUF;
 124   3                  rs485.RX4_rev_cnt++;
 125   3              }
 126   2              /* 6, 重置接收完毕判断时间                              */
 127   2              rs485.RX4_rev_timeout = 5;
 128   2          }
 129   1      }
 130          
 131          void Tim0_ISR( void ) interrupt 1   //1ms
 132          {
 133   1          /* 1, 如果接收未超时                                             */
 134   1          if ( rs485.RX4_rev_timeout != 0 )  
 135   1          {
 136   2              rs485.RX4_rev_timeout--;
 137   2              /* 2, 如果接收超时                                          */
 138   2              if( rs485.RX4_rev_timeout == 0 )  
 139   2              {
 140   3                  if( rs485.RX4_rev_cnt > 0 )  
 141   3                  {   
 142   4                       /* 3, 接收完毕标志位亮起并初始化接收缓冲区         */
 143   4                      rs485.RX4_rev_end_Flag = 1;    
 144   4                  }
 145   3              }
 146   2          } 
 147   1      }
 148          
 149          void Modbus_Event_485( void )
 150          {
 151   1          uint16_t crc,rccrc;
 152   1          
 153   1          /*1.接收完毕                                           */
 154   1          if( rs485.RX4_rev_end_Flag == 1 )
 155   1          {
 156   2              /*2.清空接收完毕标志位                              */    
 157   2              rs485.RX4_rev_end_Flag = 0;
 158   2      
 159   2              /*3.CRC校验                                         */
 160   2              crc = MODBUS_CRC16(rs485.RX4_buf, rs485.RX4_rev_cnt-2);
 161   2              rccrc = (rs485.RX4_buf[rs485.RX4_rev_cnt-1]) | (rs485.RX4_buf[rs485.RX4_rev_cnt-2]<<8);
 162   2      
 163   2              /*4.清空接收计数                                    */
 164   2              rs485.RX4_rev_cnt = 0; 
 165   2      
 166   2              /*5.CRC校验通过，进行地址域校验                      */
 167   2              if( crc == rccrc )
 168   2              {
 169   3                  /*6.地址域校验通过，进入相应功能函数进行处理      */
 170   3                  if( rs485.RX4_buf[0] == 0XEB )
 171   3                  {
 172   4                      switch ( rs485.RX4_buf[1] )
 173   4                      {
 174   5                          case 0x03:
 175   5                              //Modbus_Fun3_485();
 176   5                              break;
 177   5      
 178   5                          case 0x04:
C51 COMPILER V9.60.7.0   MAIN                                                              05/17/2025 23:29:09 PAGE 4   

 179   5                              //Modbus_Fun4_485();
 180   5                              break;
 181   5      
 182   5                          case 0x06:
 183   5                              Modbus_Fun6_485();
 184   5                              break;  
 185   5      
 186   5                          case 0x10:  
 187   5                              //Modbus_Fun16_485();
 188   5      
 189   5                          default:
 190   5                              break;
 191   5                      }
 192   4                  }
 193   3              }
 194   2          }
 195   1      }
 196          
 197          void Modbus_Fun6_485( void )
 198          {
 199   1          static uint8_t change = 1;
 200   1          switch (rs485.RX4_buf[3])
 201   1          {
 202   2              /*  40001  风速设置                 */
 203   2              case 0x00:                  
 204   2      
 205   2                  break;
 206   2      
 207   2              /*  40002  LED 开关状态设置                          */
 208   2              case 0x01:                                         
 209   2      
 210   2      
 211   2                  break;
 212   2      
 213   2              /*  40003 三路220V输出使能设置                          */
 214   2              case 0x02:                                         
 215   2      
 216   2                  break;  
 217   2                  
 218   2              /*  40004  同步状态设置                   */
 219   2              case 0x03:                                         
 220   2              change = 1 - change;                                  
 221   2              Buzzer = change;
 222   2                  break;
 223   2      
 224   2              /*  40005  工作模式设置                   */
 225   2              case 0x04:     
 226   2              change = 1 - change;                                  
 227   2              Buzzer = change;
 228   2                  break;
 229   2      
 230   2              /*  40006  报警温度设置                   */
 231   2              case 0x05:                                         
 232   2              change = 1 - change;                                  
 233   2              Buzzer = change;
 234   2                  break;
 235   2      
 236   2              case 0x06:  
 237   2              change = 1 - change;                                  
 238   2              Buzzer = change;
 239   2                  break;
 240   2                  
C51 COMPILER V9.60.7.0   MAIN                                                              05/17/2025 23:29:09 PAGE 5   

 241   2              default:
 242   2                  break;   
 243   2          }
 244   1      
 245   1          slave_to_master_485(0x06,8);
 246   1      }
 247          
 248          void slave_to_master_485(uint8_t code_num,uint8_t length)
 249          {
 250   1          uint16_t crc;
 251   1      
 252   1          switch (code_num)
 253   1          {
 254   2              case 0x03:
 255   2                  
 256   2                  crc = MODBUS_CRC16(rs485.TX4_buf,length);
 257   2      
 258   2                  rs485.TX4_buf[length+1] = crc;                 //CRC H
 259   2                  rs485.TX4_buf[length] = crc>>8;            //CRC L
 260   2      
 261   2                  rs485.TX4_send_bytelength = length + 2;
 262   2                  
 263   2                  
 264   2                  break;
 265   2              case 0x04:
 266   2                  crc = MODBUS_CRC16(rs485.TX4_buf,length);
 267   2      
 268   2                  rs485.TX4_buf[length+1] = crc;                 //CRC H
 269   2                  rs485.TX4_buf[length] = crc>>8;            //CRC L
 270   2      
 271   2                  rs485.TX4_send_bytelength = length + 2;
 272   2                  
 273   2                  break;    
 274   2      
 275   2              case 0x06:
 276   2                  memcpy(rs485.TX4_buf,rs485.RX4_buf,8);
 277   2      
 278   2                  rs485.TX4_send_bytelength = length;
 279   2      
 280   2                  break;   
 281   2      
 282   2              case 0x10:
 283   2                  memcpy(rs485.TX4_buf,rs485.RX4_buf,6);
 284   2              
 285   2                  crc = MODBUS_CRC16(rs485.TX4_buf,6);
 286   2      
 287   2                  rs485.TX4_buf[7] = crc;                 //CRC H
 288   2                  rs485.TX4_buf[6] = crc>>8;              //CRC L
 289   2              
 290   2                  rs485.TX4_send_bytelength = length;
 291   2                  
 292   2                  break;         
 293   2      
 294   2              default:
 295   2                  break;
 296   2          }
 297   1      
 298   1          DR_485 = 1;                                 //485可以发送
 299   1          delay_ms(2);
 300   1          S4CON |= S4TI;                              //开始发送
 301   1          delay_ms(1);
 302   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              05/17/2025 23:29:09 PAGE 6   

 303          
 304          void delay_ms(uint16_t time)    //@11.0592MHz
 305          {
 306   1              unsigned char data i, j;
 307   1          for(time;time>0;time--)
 308   1          {
 309   2              _nop_();
 310   2              _nop_();
 311   2              _nop_();
 312   2              i = 11;
 313   2              j = 190;
 314   2              do
 315   2              {
 316   3                  while (--j);
 317   3              } while (--i);
 318   2          }
 319   1      }
 320          
 321          uint16_t MODBUS_CRC16(uint8_t *buf, uint8_t length)
 322          {
 323   1              uint8_t i;
 324   1              uint16_t        crc16;
 325   1      
 326   1          /* 1, 预置16位CRC寄存器为0xffff（即全为1）                          */
 327   1              crc16 = 0xffff; 
 328   1      
 329   1              do
 330   1              {
 331   2              /* 2, 把8位数据与16位CRC寄存器的低位相异或，把结果放于CRC寄存器     */    
             -    
 332   2                      crc16 ^= (uint16_t)*buf;                //
 333   2                      for(i=0; i<8; i++)              
 334   2                      {
 335   3                  /* 3, 如果最低位为1，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位 再异或0xA001    */
 336   3                              if(crc16 & 1)
 337   3                  {
 338   4                      crc16 = (crc16 >> 1) ^ 0xA001;
 339   4                  }
 340   3                  /* 4, 如果最低位为0，把CRC寄存器的内容右移一位(朝低位)，用0填补最高
             -位                */
 341   3                  else
 342   3                  {
 343   4                      crc16 >>= 1;
 344   4                  }           
 345   3                      }
 346   2                      buf++;
 347   2              }while(--length != 0);
 348   1      
 349   1              return  (crc16);
 350   1      }
 351          
 352          void main( void )
 353          {
 354   1          P_SW2 |= 0x80;
 355   1          
 356   1          GPIO_Init();
 357   1      
 358   1          /*  485控制  */
 359   1          Uart4_Init();               //串口4用作485
 360   1          Uart4_Send_Statu_Init();    //接收发送初始化
 361   1      
C51 COMPILER V9.60.7.0   MAIN                                                              05/17/2025 23:29:09 PAGE 7   

 362   1          Timer0_Init();              //不定长数据接收
 363   1      
 364   1      
 365   1          EA = 1;     //中断总开关
 366   1      
 367   1          while (1)
 368   1          {
 369   2              Modbus_Event_485();
 370   2          }  
 371   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    777    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    264       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
